# 操作系统概述

## 1.什么是操作系统

**计算机**是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：

- 硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等；
- 软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、微信等应用程序。

**操作系统（Operating System，OS）**是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。

操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如：

**1.文件系统**

提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。

**2.设备驱动程序**

提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。简单来说，就是让你能吃到鸡蛋，但不用养一只鸡。

**3.用户接口**

操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。

**4.系统服务程序**

当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。

> 打个比方，操作系统就好像是一个政府，其它软件都会被它管控；操作系统在给其他软件提供各种便利的同时，还会约束其他软件不能为所欲为。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/caozuoxitonggaishu.png"/> </div>



<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/caozuoxitongtushi.png"/> </div>

目前流行的服务器和 PC 端操作系统有 Linux、Windows、macOS、UNIX 等，手机操作系统有 Android、iOS，嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等。

操作系统本质上是运行在计算机上的软件/程序，作为硬件基础上的第一层软件，操作系统是硬件和各种软件沟通的桥梁。其功能大致可分为两个部分：

- **管理计算机硬件与软件资源**
- **向用户提供一个与系统交互的操作界面**（专业的叫法是 **壳 Shell**）

## 2. 计算机硬件简单介绍

一台简单的个人计算机可以抽象为类似于下图中的模型：

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/jiandanmoxing.png"/> </div>

CPU、内存以及 I/O 设备都由一条系统总线连接起来并通过总线与其他设备通信

### 处理器

所谓处理器也就是我们常说的 CPU，它是计算机的**大脑**。CPU 从内存中提取指令并执行它。一个 CPU 的执行周期是从内存中提取一条指令、解码并决定它的类型和操作数，接着执行之，然后再提取、解码并执行下一条指令。重复该循环直到程序运行完毕

简单来说，大家记住这句话就行：**一个程序需要放入内存并给它分配 CPU 才能执行**。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/cputu.png"/> </div>

### 存储器

计算机中第二个主要的组件就是存储器。**理想情况下**，存储器应该**非常快速**，比执行一条指令要快，从而使得 CPU 的执行效率不会收到存储器的影响，而且**足够大且非常便宜**。

但是目前的技术手段无法同时满足这三个目标，于是出现了不同的处理方式。存储器系统采用一种分层次的结构，如下图所示，**顶层的存储器速度最快、容量最小、成本最高，越往下层存储器的速度越慢、容量越大、成本也越低**。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/cunchuqi.png"/> </div>

为什么访问**寄存器**的速度这么快呢？那是因为寄存器的材料和 CPU 是相同的，所以和访问 CPU 比起来几乎是没有时延的。

寄存器的下一个层次是**缓存**，想必大家并不陌生，通常缓存的使用会带来性能上的改善。操作系统一直都在使用缓存，比如说在内存中保留频繁使用的文件，以避免从磁盘上重复地调取这些文件。

再往下一层就是**内存**，也称**主存**，通常被称为**随机访问存储器**（Random Access Memory，**RAM**）。所有不能在缓存中得到满足的访问请求都会转往内存。

除了内存 RAM 之外，许多计算机还具有少量的**非易失性随机存取存储器**（Read Only Memory，**ROM**）。它们与 RAM 不同，在电源断电后，ROM 并不会丢失内容，其中的内容一旦存储后就不会再被修改。而且 ROM 非常快而且便宜。

下一个层次是**磁盘**，其容量更大，磁盘唯一的问题就是随机访问数据的时间比内存大约慢了三个数量级，其低速的原因是因为**磁盘是一种机械装置并且拥有一种特殊的构造**，如下图所示：

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/cipantu.png"/> </div>

在一个磁盘中有一个或多个金属**盘片**，它们以 5400、7200、10800 rpm 或更高的速度旋转。从边缘开始有一个**机械臂**悬横在盘面上，这种情形大伙可以回想一下老式的播放塑料唱片机。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个**磁头**可以读取一段环形区域，称为**磁道**（track）。把一个给定臂的位置上的所有磁道合并起来，就组成了一个**柱面**（cylinder）。

每个磁道划分若干**扇区**，扇区的值是 512 字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要 1ms。而随机移到一个柱面的典型时间为 5ms 至 10ms，其具体时间取决于驱动器。磁臂到达正确的磁道上后，驱动器必须等待所需的扇区旋转到磁头之下（这大概需要 5ms 至 10ms 的时延），再开始读写，低端硬盘的速率是 `50MB/s`，而高速磁盘的速率是 `160MB/s`。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/cidaotu.png"/> </div>

### I/O 设备

CPU 和存储器并不是操作系统唯一需要管理的资源，I/O 设备与操作系统同样密不可分。如下图所示，I/O 设备一般包括两个部分：**设备控制器和设备本身**，比如键盘控制器和键盘。

**设备控制器**其实就是一块芯片或者一组芯片，它能够接收操作系统的指令并控制物理设备。例如，从设备中读取数据并完成数据的处理。

在许多情况下，实际控制设备的过程是非常复杂而且存在诸多细节。因此控制器的工作就是为操作系统提供一个更简单（但仍然非常复杂）的接口。

I/O 设备另一部分是**设备本身**，设备本身有一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被**标准化**了，标准化后任何一个磁盘控制器就可以适配任意一种磁盘，所以标准化是非常必要的。

## 3. 操作系统的四个特征(基本特征)

操作系统拥有 4 个鲜明的特征：并发、共享、虚拟和异步。其中，**并发和共享是操作系统的最基本特征**，没有并发和共享，就谈不上虚拟和异步。

### 1. 并发

并发和并行这两个孪生兄弟，经常会让初学者摸不着头脑。

- **并发**：并发是指宏观上在**一段时间内**能同时运行多个程序。当然，这些程序宏观上是同时发生的，但微观上是交替发生的。操作系统通过引入进程和线程，使得程序能够并发运行。
- **并行**：并行则指**同一时刻**能运行多个指令，指两个或多个事件在**同一时刻同时发生**。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

说到并发与并行，不得不提 CPU，作为计算机的大脑， CPU 主要和内存进行交互，从内存中提取指令并执行。而一个程序需要放入内存并给它分配 CPU 才能执行，所以并发并行的能力与 CPU 的性能息息相关：

- **单核 CPU**同一时刻只能执行一个程序，各个程序只能**并发**地执行；
- **多核 CPU**同一时刻可以同时执行多个程序，多个程序可以**并行**地执行。

比如 Intel 的第八代 i3 处理器就是 4 核 CPU，意味着可以并行地执行 4 个程序。当然，即使是对于 4 核 CPU 来说，只要有 4 个以上的程序需要 “同时” 运行，那么并发性依然是必不可少的，因此**并发性是操作系统一个最基本的特征**。

### 2. 共享

共享即**资源共享**，是指系统中的资源可供内存中多个**并发**执行的进程共同使用。

主要有两种共享方式：

1）**互斥共享**

所谓互斥共享，就是说虽然这个资源是共享的，所有进程都能够使用，但是**同一个资源在某一时刻只允许一个进程访问**，也称为互斥访问，需要用同步机制来实现互斥访问。互斥共享/访问的资源称为**临界资源**。

互斥共享的例子：

如果我们同时使用 QQ 和微信视频，同一时间段内摄像头资源只能分配给其中的一个进程。

2）**同时共享**

同时共享与互斥共享相反，**允许一个时间段内多个进程 “同时” 对系统中的某些资源进行访问**。当然，所谓的 “同时” 往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问（即分时共享）

同时共享的例子：

使用 QQ 发送硬盘上的文件 A，同时使用微信发送硬盘上的文件 B。宏观上看，两边在同时读取并发送文件， 都在访问硬盘资源，并从中读取数据。微观上看，QQ 和微信这两个进程是交替访问硬盘资源的。

**并发和共享作为操作系统的两大最基本特征，其实是互为存在条件的**。为什么这么说呢？这样，我们继续通过上述发送文件的例子来看并发与共享的关系（使用 QQ 发送硬盘上的文件 A，同时使用微信发送硬盘上的文件 B）：

- 并发性的体现：两个进程正在并发执行。

  如果失去并发性，系统中只有一个程序正在运行，则共享性失去存在的意义

- 共享性的体现：两个进程需要共享地访问硬盘资源。

  如果失去共享性，则 QQ 和微信不能同时访问硬盘资源，就无法实现同时发送文件，并发也就无从谈起

### 3. 虚拟

定义：虚拟是指**把一个物理上的实体变为若干个逻辑上的对应物**。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。

比如：

上文说过，一个程序需要放入内存并给它分配 CPU 才能执行。那比如说 GTA5 需要 4GB 的运行内存，QQ 需要256MB 的内存，Chrome 需要 512MB 的内存，网易云音乐需要 256MB 的内存，假设我们的电脑只有 4GB 内存且 CPU 是单核的。那么这里就存在如下两个问题：

**问题 1**：这些程序同时运行需要的内存远大于 4 GB，那么为什么它们还可以在我的电脑上同时运行呢？

答：这得益于虚拟内存技术的**空（空间）分复用技术**。虽然我们的电脑实际上只有 4GB 的内存，但是却可以完美的同时运行这些远大于 4G 内存的程序，**在用户看来似乎我们的电脑内存远远大于 4GB**。

**问题 2**：既然一个程序需要被分配 CPU 才能正常执行，那为什么单核 CPU 的电脑中也能同时运行这么多个程序呢？

答：这得益于虚拟内存技术的**时（时间）分复用技术**。虽然实际上只有一个单核 CPU，无法同时并行执行这么多个程序，但是微观上 CPU 在各个微小的时间段内交替着为各个进程服务，**在用户看来似乎我们的 CPU 是多核的**。

下面我们来解释一下上述两种虚拟技术：

1）**空分复用技术**

空分复用技术的原理就是把内存作为高速缓存来使用，只用来保存最频繁使用的部分程序，而把程序的大部分放在磁盘上。这种机制需要快速的映像内存地址，以便把程序生成的地址转换为有关字节在内存中的物理地址。这种映像由 CPU 中的一个部件，称为**存储器管理单元**（Memory Management Unit，**MMU**）来完成，这张图上面我们也看过了：

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/jiandanmoxing.png"/> </div>

2）**时分复用技术**

多个进程能在同一个 CPU 上并发执行就是因为使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

显然，如果失去了并发性，一个时间段内系统中只能运行一道程序，那也就失去了实现虚拟性的意义了。因此，**没有并发性，就谈不上虚拟性**

### 4. 异步

异步是指：在多道程序环境下，允许多个程序并发执行，但**由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进**，这就是进程的异步性。

如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。因此，**只有系统拥有并发性，才有可能导致异步性**。

## 4. 操作系统的核心内容(基本功能)

### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

进程（Process）这个概念在上文中已经多次出现了，为了能更好地实现操作系统的并发性和共享性，遂引入了进程。

**进程就是程序的一次执行过程，它是暂时的。不仅包含正在运行的程序实体，并且包括这个运行的程序中占据的所有系统资源，比如说 CPU、内存、网络资源等**。很多小伙伴在回答进程的概念的时候，往往只会说它是一个运行的实体，而会忽略掉进程所占据的资源。比如说，同样一个程序，同一时刻被两次运行了，那么他们就是两个独立的进程。

讲到进程不得不说一下线程，**一个进程中可以有多个线程，它们共享进程资源。**

举个例子，QQ 和 Chrome 浏览器是两个进程，Chrome 进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

我们所说的进程管理其实主要包含两个内容：

- 进程通信
- 进程调度

**进程通信**顾名思义，就是进程之间的相互交流。CPU 作为计算机最宝贵的资源，一个进程需要放入内存并给它分配 CPU 才能执行，而一个程序可能包含多个进程，这就需要进程之间进行相互交流，彼此同步，共同完成这个程序。举个例子，如果进程 A 产生数据而进程 B 打印数据，那么 B 在 A 产生数据之前就必须等待，那么 A 是不是就得给 B 发消息，告诉 B 我生产了数据，你可以打印了。

**进程调度**就是说，通常情况下，会有多个进程或线程同时竞争 CPU，如果恰好只有一个 CPU 可用，这就导致 CPU 必须对下一个运行的进程或线程做出选择，这个选择的过程就是进程调度。

### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

高速缓存作为除寄存器外最底层的存储器，其管理是由硬件完成的

在上文操作系统的四个特征中虚拟这个特征时就说过了，内存一般用来保存正在执行的程序，在非常简单的操作系统中，内存中每次只能运行一个程序，如果要运行第二个程序，第一个程序就必须被移除内存，再把第二个程序装入内存。

显然这样非常低效的，为此引入了虚拟内存技术，把内存作为高速缓存来使用，只用来保存最频繁使用的部分程序，而把程序的大部分放在磁盘上。

那么内存管理做的事情大概就是：

- 把使用频繁的部分程序放入内存
- 当内存满的时候，替换掉内存中的某些部分

### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

文件其实是进程创建的信息逻辑单元，一个磁盘可能含有几千甚至几百万个文件，每个文件都是独立于其他文件的，事实上，把每个文件看成一种地址空间更容易理解文件的本质。

文件同样是受操作系统管理的，有关文件的构造、命名、存取、使用、保护、实现和管理方法都是操作系统设计的内容

### 4. I/O 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

操作系统必须高效的管理 I/O 设备，它需要向 I/O 设备发送命令，捕捉中断，并处理设备的各种错误，它还应该在设备和系统的其他部分之间提供简单且易用的接口。

## 5.宏内核和微内核

### 1. 宏内核

宏内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

### 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/hongweineihe.png"/> </div>

## 6.内核态和用户态

内核这个专有名词可能会让大家有点懵逼。这里解释一下。现代操作系统都采用进程的概念，为了更好的处理系统的并发性、共享性等，并使进程能够协调地工作，仅依靠计算机硬件提供的功能是远远不够的。例如，进程的调度就不能用硬件来实现，必须使用一组基本软件对硬件资源进行改造，以便为进程的执行提供良好的运行环境，这个软件就是内核（kernel）。

简单来说，**内核就是操作系统中的一组程序模块**，作为可信软件来提供支持进程并发执行的基本功能和基本操作，**具有访问硬件设备和所有内存空间的权限**。不夸张的说，内核是操作系统的核心。

当然，操作系统除了内核程序外，还有包括其他一些基本组件，如文本编辑器、编译器、用来与用户进行交互的程序比如桌面系统等。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/yonghuneihetai.png"/> </div>

### 1.什么是内核态和用户态

那么既然内核是程序，它需要运行，就必须被分配 CPU。因此，CPU 上会运行两种程序，一种是操作系统的内核程序（也称为系统程序），一种是应用程序。前者完成系统任务，后者实现应用任务。两者之间有控制和被控制的关系，前者有权管理和分配资源，而后者只能向系统申请使用资源。

显然，我们应该把在 CPU 上运行的这两类程序加以区分，这就是内核态和用户态出现的原因。

- **内核态**（kernel mode）：当 CPU 处于内核态时，这是操作系统管理程序（也就是内核）运行时所处的状态。运行在内核态的程序可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等。
- **用户态**（user mode）：应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问当前 CPU 上执行程序所在的地址空间，这样有效地防止了操作系统程序受到应用程序的侵害。

对操作系统来说，**什么样的程序应该放在内核态呢**？这取决于对资源的需求、时间的紧迫和效率高低等因素。比如 CPU、内存、设备等资源管理器程序应该在内核态运行，否则安全性没有保证。对于文件系统和数据来说，文件系统数据和管理必须放在内核态，但是用户的数据和管理可以放在用户态。

### 2.中断机制

在合适的情况下，操作系统的内核会把 CPU 的使用权主动让给应用程序，也就是使 CPU 从内核态转换到用户态。而 CPU 要想从用户态回到内核态，只能通过中断机制完成，如果没有中断机制，那么一旦应用程序上 CPU 运行（用户态），CPU 就会一直运行这个应用程序。也就是说，**中断是让操作系统内核夺回 CPU 使用权的唯一途径**。可以说，**操作系统是由中断驱动的**。

当然，这里的中断机制非常广义，包含了三种手段，也就是说从用户态转换到内核态有三种手段：

- 1）程序请求操作系统服务，执行系统调用
- 2）程序运行时产生外中断事件（比如 I/O 操作完成），运行程序被中断，转向中断程序处理
- 3）在程序运行时发生内中断（异常）事件，运行程序被打断，转向异常处理程序工作

以上这三种手段都是通过中断机制来发生的，那么接下来我们就来看看中断到底有哪些类型。

按照中断信号来源于CPU 的外部还是内部，将中断类型分为外中断和内中断：

- **外中断** （也称中断，狭义上的中断）

  外中断与当前执行的指令无关， 中断信号来源于 CPU 外部。如 I/O 完成中断，表示设备输入/输出处理已经完成，CPU 能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

- **内中断**（也称 异常、例外）

  内中断与当前执行的指令有关， 中断信号来源于 CPU 内部。如非法操作码、地址越界、算术溢出，除数为 0 等。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/zhongduanfenlei.png"/> </div>

这里简单解释一下**中断机制的基本原理**：不同的中断信号，肯定是需要用不同的中断处理程序来处理的。那么当 CPU 检测到中断信号后，就会根据中断信号的类型去查询**中断向量表**，以此来找到相应的中断处理程序在内存中的存放位置。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/zhongduanxiangguan.png"/> </div>

### 3.系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/xitongdianyong.png"/> </div>

Linux 的系统调用主要有以下这些：

|   Task   |          Commands           |
| :------: | :-------------------------: |
| 进程控制 |   fork(); exit(); wait();   |
| 进程通信 |  pipe(); shmget(); mmap();  |
| 文件操作 |  open(); read(); write();   |
| 设备操作 |  ioctl(); read(); write();  |
| 信息维护 | getpid(); alarm(); sleep(); |
|   安全   | chmod(); umask(); chown();  |

程序通过执行系统调用，也可以使得 CPU 从用户态转向内核态。那么系统调用和中断有啥关系呢？为什么说这种方式也属于中断机制的一种呢？那是因为**系统调用是通过陷入指令完成的**，该指令会引发内中断。

说的更详细点，操作系统作为计算机硬件之上的第一层软件，需要向上层提供一些简单易用的服务，这个上层包括用户和应用程序：

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/tianyongxitong.png"/> </div>

给用户提供的接口有图形界面 GUI 和命令接口，给应用程序提供的是**程序接口**，这个程序接口就是由一组系统调用组成的，是操作系统提供给开发人员使用的。可以理解为一种可供应用程序调用的特殊函数，**应用程序可以通过系统调用来请求获得操作系统内核的服务**。

<div align="center"> <img src="https://cdn.jsdelivr.net/gh/justcallmeseven/hexoservice/docsimg/tigongdejiekou.png"/> </div>

**系统调用的过程**简略版大致如下：

- 1）在用户态，应用程序传递系统调用参数
- 2）执行陷入指令，引发一个内中断，使 CPU 进入内核态
- 3）在内核态，执行相应的请求，内核程序处理系统调用
- 4）返回应用程序

**为什么系统调用是必须的**？

举个例子：我们去学校打印店打印论文，你按下了 WPS 的 “打印” 选项，于是打印机开始工作。 你的论文打印到一半时，另一位同学按下了 Word 的 “打印” 按钮，开始打印他自己的论文。想象一下如果两个进程可以随意的、并发的共享打印机资源，会发生什么情况？

显然，两个进程并发运行，导致打印机设备交替的收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了

如何解决这个问题？这就需要操作系统内核对共享资源进行统一的管理，并向上层提供 “系统调用” ，运行在用户态的应用程序或者进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，然后内核会对各个请求进行协调处理（进程调度）。

通过上面这个例子，我们就可以总结出什么功能会用到系统调用：**凡是与共享资源有关的操作（比如内存分配、I/O 操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出请求，由操作系统内核代为完成**。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。